/**
The MIT License (MIT)
Copyright (c) 2014-2019 by Michael Billard
 

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
 * */

using System;
using System.Collections.Generic;
using System.Threading;
using System.Linq;
using System.Text;
using UnityEngine;

namespace Snacks
{
    /// <summary>
    /// This class handles simulator thread creation, data synching, and the job list.s
    /// </summary>
    public class SnackSimThreadPool
    {
        #region Housekeeping
        /// <summary>
        /// Max number of threads allowed
        /// </summary>
        public int maxThreads = 4;

        /// <summary>
        /// List of simulator jobs waiting to be run
        /// </summary>
        public List<SimSnacks> jobList;

        private Mutex mutex;
        private List<SnackSimThread> snackThreads;
        private Dictionary<Vessel, Dictionary<string, double>> vesselResourceDurations;
        private Dictionary<Vessel, bool> convertersAssumedActive;
        #endregion

        #region SnackSimThread Delegate
        /// <summary>
        /// Handles the completion of a thread's simulation.
        /// </summary>
        /// <param name="simulator">The simulator that just finished.</param>
        private void OnThreadSimulationComplete(SimSnacks simulator)
        {
            //Record the vessel and its consumed resource durations.
            mutex.WaitOne();
            if (vesselResourceDurations.ContainsKey(simulator.vessel))
                vesselResourceDurations.Remove(simulator.vessel);
            vesselResourceDurations.Add(simulator.vessel, simulator.consumedResourceDurations);

            if (simulator.convertersAssumedActive && !convertersAssumedActive.ContainsKey(simulator.vessel))
                convertersAssumedActive.Add(simulator.vessel, true);

            mutex.ReleaseMutex();
        }

        /// <summary>
        /// Handles completion of a thread's simulation cycle.
        /// </summary>
        /// <param name="simulator">The simulator that just completed its cycle.</param>
        private void OnThreadSimulatorCycleComplete(SimSnacks simulator)
        {
        }

        /// <summary>
        /// Handles the exception generated by a simulator.
        /// </summary>
        /// <param name="simulator">The simulator that generated the exception.</param>
        /// <param name="ex">The Exception generated.</param>
        private void OnSimulatorException(SimSnacks simulator, Exception ex)
        {

        }
        #endregion

        #region Constructors
        public SnackSimThreadPool()
        {
            jobList = new List<SimSnacks>();
            mutex = new Mutex();
            snackThreads = new List<SnackSimThread>();
            vesselResourceDurations = new Dictionary<Vessel, Dictionary<string, double>>();
            convertersAssumedActive = new Dictionary<Vessel, bool>();

            maxThreads = SnacksScenario.Instance.maxThreads;

            SnackSimThread snackThread; ;
            for (int index = 0; index < maxThreads; index++)
            {
                snackThread = new SnackSimThread(mutex, jobList);
                snackThread.OnSimulationComplete = OnThreadSimulationComplete;
                snackThread.OnSimulatorCycleComplete = OnThreadSimulatorCycleComplete;
                snackThread.Start();
            }
        }
        #endregion

        #region API
        /// <summary>
        /// Locks the vessel resource durations so that we can query them.
        /// Be sure to call UnlockResourceDurations when done.
        /// </summary>
        public void LockResourceDurations()
        {
            mutex.WaitOne();
        }

        /// <summary>
        /// Unlocks resource durations so that threads can operate on them.
        /// </summary>
        public void UnlockResourceDurations()
        {
            mutex.ReleaseMutex();
        }

        /// <summary>
        /// Returns the vessel resource definitions for the requested vessel.
        /// Be sure to call LockResourceDurations before calling this method.
        /// Be sure to call UnlockResourceDurations after you're done.
        /// </summary>
        /// <param name="vessel">The vessel to query</param>
        /// <returns>The resource durations for the specified vessel, or null if they don't exist.</returns>
        public Dictionary<string, double> GetVesselResourceDurations(Vessel vessel)
        {
            if (vesselResourceDurations.ContainsKey(vessel))
                return vesselResourceDurations[vessel];
            else
                return null;
        }

        /// <summary>
        /// Determines whether or not the simulator had to assume that converters were on.
        /// </summary>
        /// <param name="vessel">The vessel to query</param>
        /// <returns>true if the simulator couldn't determine activation state and had to assume converters were on; false if not.</returns>
        public bool ConvertersAssumedActive(Vessel vessel)
        {
            if (convertersAssumedActive.ContainsKey(vessel))
                return convertersAssumedActive[vessel];
            else
                return false;
        }

        /// <summary>
        /// Removes the vessel resource durations for the specified vessel if they exist.
        /// Be sure to call LockResourceDurations before calling this method.
        /// Be sure to call UnlockResourceDurations after you're done.
        /// </summary>
        /// <param name="vessel">The vessel that will no longer have resource durations.</param>
        public void RemoveVesselResourceDurations(Vessel vessel)
        {
            if (vesselResourceDurations.ContainsKey(vessel))
                vesselResourceDurations.Remove(vessel);
            if (convertersAssumedActive.ContainsKey(vessel))
                convertersAssumedActive.Remove(vessel);
        }

        /// <summary>
        /// Adds a simulator to the job list.
        /// </summary>
        /// <param name="simulator">The SimSnacks simulator to add to the list.</param>
        public void AddSimulatorJob(SimSnacks simulator)
        {
            mutex.WaitOne();

            jobList.Add(simulator);

            mutex.ReleaseMutex();
        }

        /// <summary>
        /// Stops all current and pending jobs.
        /// </summary>
        public void StopAllJobs()
        {
            mutex.WaitOne();

            //Clear existing job list
            jobList.Clear();

            //Now stop all the threads
            int count = snackThreads.Count;
            for (int index = 0; index < count; index++)
                snackThreads[index].canRun = false;

            mutex.ReleaseMutex();
        }
        #endregion
    }
}
